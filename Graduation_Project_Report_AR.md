# تقرير مشروع التخرج

## تطبيق مواقف السيارات الذكي — واجهة Flutter الأمامية

---

## فهرس المحتويات

1. [نظرة عامة على المشروع](#1-نظرة-عامة-على-المشروع)
2. [هيكلية التطبيق](#2-هيكلية-التطبيق)
3. [إدارة الحالة](#3-إدارة-الحالة)
4. [التقنيات والحزم المستخدمة](#4-التقنيات-والحزم-المستخدمة)
5. [شرح الميزات الرئيسية](#5-شرح-الميزات-الرئيسية)
6. [معالجة الأخطاء وتجربة المستخدم](#6-معالجة-الأخطاء-وتجربة-المستخدم)
7. [الأداء وجودة الكود البرمجي](#7-الأداء-وجودة-الكود-البرمجي)
8. [اعتبارات الأمان](#8-اعتبارات-الأمان)
9. [الخلاصة](#9-الخلاصة)

---

## 1. نظرة عامة على المشروع

### 1.1 الفكرة العامة

**تطبيق مواقف السيارات الذكي** هو تطبيق جوال متعدد المنصات تم بناؤه باستخدام إطار عمل Flutter. يعمل التطبيق كنظام شامل لإدارة مواقف السيارات يربط بين مالكي المواقف والسائقين الباحثين عن أماكن ركن متاحة. يوفر التطبيق معلومات فورية عن توافر المواقف من خلال خريطة تفاعلية، ويتيح الحجز والدفع إلكترونيًا، كما يقدم لوحة تحكم إدارية لأصحاب المواقف لمتابعة عملياتهم.

يتواصل التطبيق مع خادم خلفي (Backend) عن بُعد من خلال واجهات برمجة التطبيقات RESTful APIs. يركز هذا التقرير حصريًا على تطبيق Flutter الأمامي (Frontend).

### 1.2 المستخدمون المستهدفون

يخدم التطبيق فئتين رئيسيتين من المستخدمين:

- **السائقون (المستخدمون العاديون):** الأفراد الذين يحتاجون إلى العثور على مواقف قريبة، والاطلاع على التوافر بشكل فوري، وحجز أماكن الركن والدفع إلكترونيًا، وإدارة مركباتهم المسجلة، ومتابعة حجوزاتهم النشطة مع مؤقتات عد تنازلي.

- **أصحاب المواقف:** مشغّلو الأعمال الذين يسجلون مواقفهم على المنصة، ويتابعون نسب الإشغال والإيرادات من خلال لوحة تحكم مخصصة، ويطّلعون على إحصائيات الحجوزات، ويديرون معلومات مواقفهم.

### 1.3 الهدف الرئيسي

الهدف الأساسي من هذا المشروع هو تقليل الوقت والجهد الذي يبذله السائقون في البحث عن مواقف للسيارات، وذلك من خلال رقمنة عملية اكتشاف المواقف وحجزها ودفع رسومها. أما بالنسبة لأصحاب المواقف، فالهدف هو توفير أداة مركزية لإدارة عملياتهم والحصول على رؤى واضحة حول نسب الإشغال وأداء الإيرادات.

---

## 2. هيكلية التطبيق

### 2.1 الهيكل العام

يتبع المشروع مبادئ **Clean Architecture** (الهندسة النظيفة)، التي تفرض فصلًا واضحًا بين واجهة المستخدم ومنطق الأعمال وطبقة الوصول إلى البيانات. تم تنظيم مجلد `lib/` إلى الوحدات الرئيسية التالية:

| المجلد | المسؤولية |
|--------|-----------|
| `core/` | الأدوات المشتركة، والأنماط، والسمات، والعناصر المرئية (Widgets)، والخدمات، وحقن التبعيات (Dependency Injection)، والتوجيه (Routing)، ودعم الترجمة المستخدمة في جميع الميزات. |
| `data/` | طبقة البيانات على مستوى التطبيق بالكامل، وتحتوي على إعدادات الشبكة (عميل Dio HTTP، وإعدادات الـ API) ومستودعات التخزين المحلي لرموز المصادقة وإعدادات التطبيق. |
| `features/` | وحدات الميزات، حيث تغلف كل وحدة طبقات البيانات والمجال والعرض الخاصة بها. |
| `l10n/` | ملفات الترجمة التي تدعم اللغتين العربية والإنجليزية. |

### 2.2 هيكل وحدة الميزة

كل وحدة ميزة داخل `features/` منظمة في ثلاث طبقات فرعية وفقًا لنمط Clean Architecture:

```
feature/
├── data/
│   ├── datasources/       # مصادر البيانات البعيدة (API)
│   ├── models/            # كائنات نقل البيانات (Data Transfer Objects - تحليل JSON)
│   └── repositories/      # التطبيقات الفعلية للمستودعات (Repository Implementations)
├── domain/
│   ├── entities/          # كائنات الأعمال الصرفة (بدون أي اعتماد على إطار العمل)
│   ├── repositories/      # واجهات المستودعات المجردة (Abstract Repository Interfaces)
│   └── usecases/          # حالات الاستخدام (Business Logic Use Cases)
└── presentation/
    ├── bloc/              # فئات BLoC (الأحداث، الحالات، المنطق)
    ├── pages/             # صفحات الشاشات (Screen-level Widgets)
    └── widgets/           # عناصر واجهة مستخدم قابلة لإعادة الاستخدام خاصة بهذه الميزة
```

يضمن هذا النهج الطبقي ما يلي:

- **طبقة البيانات (Data Layer)** مسؤولة عن التواصل مع الـ Backend API وتحويل استجابات JSON إلى كائنات نموذجية (Model Objects).
- **طبقة المجال (Domain Layer)** تُعرّف كائنات الأعمال الصرفة وفئات حالات الاستخدام (Use Cases) التي تغلف وحدة واحدة من منطق الأعمال. لا تعتمد هذه الطبقة على Flutter أو أي حزمة خارجية.
- **طبقة العرض (Presentation Layer)** تدير واجهة المستخدم والتفاعلات، وتعتمد على نمط BLoC لإدارة الحالة.

### 2.3 فصل المسؤوليات (Separation of Concerns)

تفصل الهيكلية المسؤوليات بشكل صارم من خلال الآليات التالية:

- **نمط المستودع (Repository Pattern):** يتم تعريف واجهات المستودعات المجردة في طبقة المجال، بينما توجد التطبيقات الفعلية في طبقة البيانات. هذا يسمح لمنطق الأعمال بالبقاء مستقلًا عن كيفية جلب البيانات.
- **حالات الاستخدام (Use Cases):** كل عملية أعمال مستقلة (مثل البحث عن مواقف قريبة أو دفع مخالفة) مغلفة في فئة Use Case خاصة بها. هذا يجعل منطق الأعمال قابلًا للاختبار وإعادة الاستخدام.
- **حقن التبعيات (Dependency Injection):** يقوم محدد الخدمات `GetIt` (في ملف `service_locator.dart`) بتسجيل جميع مصادر البيانات والمستودعات وحالات الاستخدام وكائنات BLoC بشكل مركزي. هذا يعزز الترابط الضعيف (Loose Coupling)، حيث تتلقى المكونات تبعياتها من خلال الحقن بدلًا من الإنشاء المباشر.

### 2.4 التوجيه والتنقل (Routing and Navigation)

يستخدم التطبيق حزمة `go_router` للتنقل التصريحي المبني على المسارات (URL-based Navigation). تشمل قرارات التوجيه الرئيسية:

- استخدام `StatefulShellRoute.indexedStack` لعلامات التبويب في شريط التنقل السفلي، مما يحافظ على حالة كل علامة تبويب عند التنقل بينها.
- تطبيق انتقالات صفحات مخصصة (Custom Page Transitions) لشاشات المصادقة لتحسين التجربة البصرية.
- تعريف مسارات التوجيه كثوابت في ملف `app_routes.dart`، لتجنب كتابة نصوص المسارات بشكل مباشر في الكود.
- توفير كائنات BLoC على مستوى المسارات المحددة (Route-level BLoC Providers)، مما يضمن إنشاء الحالة والتخلص منها في نقطة دورة الحياة المناسبة.

---

## 3. إدارة الحالة (State Management)

### 3.1 النهج المختار: BLoC (Business Logic Component)

يستخدم التطبيق حزمة **flutter_bloc** (الإصدار 8.1.6) كحل لإدارة الحالة. تم اختيار نمط BLoC للأسباب التالية:

1. **فصل واضح:** يفرض BLoC تدفقًا أحادي الاتجاه للبيانات، حيث ترسل واجهة المستخدم **أحداثًا (Events)** وتستقبل **حالات (States)**. هذا يجعل المنطق قابلًا للتنبؤ وسهل التتبع.
2. **قابلية التوسع:** لكل ميزة BLoC خاص بها (أو عدة BLoCs)، مما يمنع وجود كائن حالة واحد ضخم ويجعل التطبيق أسهل في الصيانة مع نموه.
3. **قابلية الاختبار:** بما أن فئات BLoC هي فئات Dart عادية تستقبل أحداثًا وتصدر حالات، يمكن اختبارها بشكل وحدوي (Unit Testing) دون الحاجة إلى أي تبعيات من عناصر Flutter المرئية.

### 3.2 كيفية تدفق الحالة

تتبع إدارة الحالة نمطًا متسقًا عبر جميع الميزات:

```
  تفاعل المستخدم
        │
        ▼
  واجهة المستخدم ترسل حدثًا (Event) إلى BLoC
        │
        ▼
  يعالج BLoC الحدث
   (يستدعي Use Case ← Repository ← API)
        │
        ▼
  يصدر BLoC حالة جديدة (State)
        │
        ▼
  واجهة المستخدم تعيد البناء استجابةً للحالة الجديدة
```

**مثال عملي — تدفق تسجيل الدخول:**

1. يقوم المستخدم بملء حقلي البريد الإلكتروني وكلمة المرور. كل ضغطة مفتاح ترسل حدث `UpdateEmail` أو `UpdatePassword`.
2. عندما يضغط المستخدم على زر تسجيل الدخول، يتم إرسال حدث `SendLoginRequest`.
3. يقوم `LoginBloc` بالتحقق من صحة حقول الإدخال. إذا فشل التحقق، يصدر حالة تحتوي على رسائل أخطاء على مستوى الحقول.
4. إذا نجح التحقق، يصدر BLoC حالة `LoginLoading`، ثم يستدعي API المصادقة، وبعدها يصدر إما `LoginSuccess` (مع بيانات المستخدم) أو `LoginFailure` (مع رسالة الخطأ).
5. تستمع واجهة المستخدم لهذه التغييرات في الحالة: تعرض مؤشر تحميل أثناء `LoginLoading`، وتنتقل إلى الشاشة الرئيسية عند `LoginSuccess`، أو تعرض رسالة خطأ (Snackbar) عند `LoginFailure`.

### 3.3 BLoC على مستوى التطبيق مقابل BLoC على مستوى الميزة

- **BLoC على مستوى التطبيق** (مثل `LocaleCubit` لتبديل اللغة و`SplashRoutingBloc` للتوجيه الأولي) يتم توفيرها في جذر شجرة العناصر المرئية (Widget Tree) باستخدام `MultiBlocProvider`.
- **BLoC على مستوى الميزة** (مثل `VehiclesBloc` و`NotificationsBloc` و`ParkingMapBloc`) يتم توفيرها على مستوى المسار عبر `BlocProvider`، مما يضمن إنشاءها عند انتقال المستخدم إلى الميزة والتخلص منها عند مغادرته.

### 3.4 العمليات غير المتزامنة مع AsyncRunner

يقدم التطبيق أداة مخصصة تسمى `AsyncRunner` تغلف عمليات BLoC غير المتزامنة وتوفر:

- **منطق إعادة المحاولة (Retry Logic)** مع تأخير تصاعدي (Exponential Backoff) لأخطاء الشبكة المؤقتة.
- **دعم الإلغاء** باستخدام `CancelToken` من Dio، مما يسمح بإلغاء طلبات API الجارية عند انتقال المستخدم إلى صفحة أخرى.
- **منع الاستدعاءات المكررة**، لضمان عدم تشغيل نفس العملية عدة مرات في وقت واحد.

---

## 4. التقنيات والحزم المستخدمة

### 4.1 إطار العمل الأساسي

| التقنية | الغرض |
|---------|-------|
| **Flutter 3.8.1+** | إطار عمل واجهات المستخدم متعدد المنصات لبناء التطبيق الجوال. |
| **Dart** | لغة البرمجة المستخدمة من قبل Flutter. |

### 4.2 الشبكة والتواصل مع الـ API

| الحزمة | الغرض |
|--------|-------|
| **dio 5.4.0** | عميل HTTP يُستخدم لجميع عمليات التواصل مع الـ API. تم اختياره بدلًا من حزمة `http` الافتراضية لدعمه لـ Interceptors وإلغاء الطلبات وتنزيل الملفات مع تتبع التقدم ومعالجة Form Data. |

طبقة الشبكة مركزية في كائن Singleton يسمى `DioProvider` يقوم بإعداد:

- تحديد عنوان الخادم الأساسي (Base URL) من خلال فئة `ApiConfig` ديناميكية (تدعم تبديل عناوين الـ API أثناء التشغيل لأغراض التطوير والاختبار).
- بانٍ للطلبات `APIRequest` يبني الطلبات مع تحديد الطريقة (Method) والترويسات (Headers) ومعاملات الاستعلام (Query Parameters) وجسم الطلب (Body) وحقن رمز المصادقة (Token) تلقائيًا.
- معترضات الأخطاء (Error Interceptors) التي تحول استثناءات Dio إلى فئة `AppException` موحدة.

### 4.3 إدارة الحالة

| الحزمة | الغرض |
|--------|-------|
| **flutter_bloc 8.1.6** | فئات BLoC وCubit لإدارة حالة التطبيق. |

### 4.4 حقن التبعيات (Dependency Injection)

| الحزمة | الغرض |
|--------|-------|
| **get_it 7.7.0** | محدد خدمات (Service Locator) لتسجيل وحل التبعيات في جميع أنحاء التطبيق. |

### 4.5 التخزين المحلي

| الحزمة | الغرض |
|--------|-------|
| **hive_flutter 1.1.0** | قاعدة بيانات خفيفة وسريعة من نوع مفتاح-قيمة (Key-Value) تُستخدم لتخزين رموز المصادقة والطلبات المُدرجة في قائمة الانتظار لدعم العمل بدون اتصال. |
| **shared_preferences** | تخزين بسيط من نوع مفتاح-قيمة لإعدادات التطبيق مثل تفضيل اللغة وحالة إكمال شاشة الترحيب وبيانات الملف الشخصي المخزنة مؤقتًا. |

### 4.6 التنقل (Navigation)

| الحزمة | الغرض |
|--------|-------|
| **go_router 14.0.0** | توجيه تصريحي يدعم التنقل المتداخل وShell Routes لأشرطة التنقل السفلية وتوفير BLoC على مستوى المسارات. |

### 4.7 الخرائط والموقع الجغرافي

| الحزمة | الغرض |
|--------|-------|
| **flutter_osm_plugin 1.4.3** | دمج خرائط OpenStreetMap لعرض مواقع مواقف السيارات على خريطة تفاعلية. |
| **geolocator 13.0.1** | الوصول إلى نظام تحديد المواقع GPS في الجهاز للحصول على الموقع الحالي للمستخدم للبحث عن مواقف قريبة. |

### 4.8 واجهة المستخدم والتجاوب

| الحزمة | الغرض |
|--------|-------|
| **flutter_screenutil 5.9.0** | أداة تخطيط متجاوبة تقوم بتحجيم الأبعاد بناءً على حجم شاشة الجهاز، مما يضمن ثبات واجهة المستخدم عبر الأجهزة المختلفة. |

### 4.9 الترجمة والتعريب (Localization)

يدعم التطبيق **اللغتين العربية والإنجليزية** باستخدام نظام الترجمة المدمج في Flutter مع ملفات ARB (Application Resource Bundle). تغطي الترجمة ما يقارب **1,987 مفتاح ترجمة**، مما يوفر دعمًا ثنائي اللغة كاملًا لجميع النصوص التي تظهر للمستخدم بما في ذلك رسائل الأخطاء ورسائل التحقق من الإدخال ورسائل النجاح.

### 4.10 حزم إضافية مهمة

| الحزمة | الغرض |
|--------|-------|
| **خطوط مخصصة (Custom Fonts)** | عائلات الخطوط IBM Plex Sans Arabic وInter وCairo لتجربة طباعية أنيقة ومتعددة اللغات. |

---

## 5. شرح الميزات الرئيسية

### 5.1 شاشة البداية (Splash Screen) وشاشات الترحيب (Onboarding)

**ما تفعله:** عند تشغيل التطبيق، تُعرض شاشة بداية بينما يحدد التطبيق إلى أين يوجّه المستخدم. يُعرض للمستخدمين الجدد تسلسل ترحيبي يقدم الغرض من التطبيق.

**كيف تعمل تقنيًا:** يقوم `SplashRoutingBloc` بتنفيذ سلسلة من القرارات:
1. يتحقق مما إذا كانت شاشات الترحيب قد اكتملت (عبر `SettingsLocalRepository`). إذا لم تكتمل، يُوجَّه المستخدم إلى شاشات الترحيب.
2. يتحقق من وجود رمز مصادقة (Token) محفوظ (عبر `AuthLocalRepository`). إذا لم يوجد رمز، يُوجَّه المستخدم إلى شاشة تسجيل الدخول.
3. إذا وُجد رمز مصادقة، يقرأ نوع المستخدم (مالك أو مستخدم عادي) ويوجّهه إلى الشاشة الرئيسية المناسبة.

**التواصل مع الخادم:** لا يتم إجراء أي استدعاءات API أثناء شاشة البداية؛ يعتمد القرار بالكامل على البيانات المخزنة محليًا.

---

### 5.2 المصادقة (تسجيل الدخول والتسجيل)

**ما تفعله:** يمكن للمستخدمين إنشاء حساب جديد بتقديم الاسم الكامل والبريد الإلكتروني ورقم الهاتف ونوع المستخدم (سائق أو مالك) وكلمة المرور. يمكن للمستخدمين الحاليين تسجيل الدخول باستخدام البريد الإلكتروني وكلمة المرور.

**كيف تعمل تقنيًا:**
- يتولى `LoginBloc` و`RegisterBloc` تحديث حقول النموذج والتحقق من صحة الإدخال على جانب العميل وإرسال طلبات API.
- يتم التحقق من صحة الإدخال باستخدام فئة `AuthValidators` المركزية التي تربط قيم enum من نوع `ValidationErrorType` برسائل أخطاء مترجمة. تُعرض الأخطاء فقط بعد محاولة المستخدم إرسال النموذج وليس أثناء الكتابة — وهو قرار مقصود لتحسين تجربة المستخدم وتقليل التشتيت.
- عند نجاح تسجيل الدخول، يتم تخزين رمز المصادقة (Token) وبيانات المستخدم محليًا باستخدام Hive. بالنسبة لأصحاب المواقف، يتم إجراء فحص إضافي للتأكد من أن الحساب نشط (معتمد من مسؤول المنصة)؛ يُمنع أصحاب الحسابات غير النشطة من المتابعة.

**التواصل مع الخادم:**
- تسجيل الدخول: طلب `POST` إلى نقطة نهاية تسجيل الدخول مع البريد الإلكتروني وكلمة المرور.
- التسجيل: طلب `POST` إلى نقطة نهاية التسجيل مع تفاصيل المستخدم الكاملة.

---

### 5.3 خريطة المواقف التفاعلية

**ما تفعله:** يمكن للسائقين عرض جميع المواقف المسجلة على خريطة تفاعلية مبنية على OpenStreetMap. تُلوَّن العلامات (Markers) بناءً على نسبة التوافر. يمكن للمستخدمين الضغط على علامة لعرض معلومات تفصيلية والحصول اختياريًا على اتجاهات القيادة أو الانتقال لحجز مكان.

**كيف تعمل تقنيًا:**
- يدير `ParkingMapBloc` حالة الخريطة بما في ذلك بيانات المواقف وموقع المستخدم والموقف المحدد ووضع البحث.
- تُعرض علامات المواقف بألوان مميزة: الأخضر للتوافر المرتفع، والبرتقالي للمتوسط، والأحمر للممتلئ تقريبًا، والرمادي للممتلئ بالكامل.
- عند ضغط المستخدم على علامة، تنزلق من الأسفل لوحة سفلية قابلة للسحب (`ParkingDetailsBottomSheet`) تعرض اسم الموقف والعنوان والأماكن المتاحة والسعر بالساعة وأزرار الإجراءات.
- يرسم زر "الحصول على الاتجاهات" مسارًا على الخريطة من موقع المستخدم إلى الموقف المحدد.
- تستخدم ميزة "البحث القريب" نظام GPS في الجهاز للعثور على مواقف ضمن نطاق قابل للتحديد.

**التواصل مع الخادم:**
- طلب `GET` لجلب جميع المواقف لعرضها على الخريطة (نقطة نهاية عامة، لا تتطلب مصادقة).
- طلب `GET` لجلب تفاصيل موقف محدد بواسطة المعرف (ID).
- طلب `GET` للبحث عن مواقف قريبة بواسطة خط العرض وخط الطول ونصف القطر (نقطة نهاية تتطلب مصادقة).

---

### 5.4 نظام الحجز

**ما يفعله:** بعد اختيار موقف سيارات، يمكن للسائق حجز مكان ركن عن طريق اختيار المدة (ساعة واحدة أو ساعتين أو عدد ساعات مخصص)، واختيار مركبة مسجلة، ثم تأكيد الحجز. تعرض الحجوزات النشطة مؤقت عد تنازلي يعمل في الوقت الفعلي.

**كيف يعمل تقنيًا:**
- تتيح شاشة `BookingPrePaymentScreen` للمستخدم اختيار المدة والمركبة. يُحسب السعر الإجمالي محليًا (سعر الساعة × عدد الساعات). عند التأكيد، يُرسل طلب إنشاء حجز.
- يقوم `BookingDetailsBloc` بتحميل تفاصيل الحجز وإدارة `BookingTimerService` الذي يوفر عدًّا تنازليًا في الوقت الفعلي. ينقص المؤقت محليًا كل ثانية ويُعيد المزامنة مع الخادم بشكل دوري (إذا كان آخر جلب من الـ API قبل أكثر من دقيقة واحدة).
- تظهر تنبيهات بصرية عندما ينخفض الوقت المتبقي عن 10 دقائق. يمكن تمديد الحجز أو إلغاؤه من شاشة التفاصيل.
- تعرض `UserHomePage` قائمة أفقية قابلة للتمرير بالحجوزات النشطة مع مؤقتات عد تنازلي حية.
- يُعالج مُعالج التعارضات الحالة التي يمتلك فيها المستخدم حجزًا نشطًا مسبقًا (استجابة HTTP 409)، فيعيد توجيهه إلى تدفق الدفع للحجز الحالي بدلًا من ذلك.

**التواصل مع الخادم:**
- طلب `POST` لإنشاء حجز.
- طلب `GET` لجلب تفاصيل الحجز والوقت المتبقي.
- طلب `POST` لتمديد أو إلغاء حجز.
- طلب `GET` لتنزيل الفواتير (تنزيل ملف مع تتبع التقدم).

---

### 5.5 إدارة المركبات

**ما تفعله:** يمكن للسائقين تسجيل مركباتهم (رقم اللوحة، النوع، اللون، إلخ)، وتعديل معلومات المركبة، وحذف المركبات التي لم يعودوا بحاجة إليها.

**كيف تعمل تقنيًا:**
- يدير `VehiclesBloc` دورة حياة العمليات الأربع (CRUD) بالكامل.
- تؤدي إضافة مركبة إلى إرسال حدث `AddVehicleRequested` الذي يستدعي `AddVehicleUseCase`. عند النجاح، يُعاد تحميل قائمة المركبات تلقائيًا.
- يؤدي تحديث مركبة إلى إنشاء **طلب تعديل** قد يحتاج إلى موافقة، بدلًا من تطبيق التغيير فورًا.
- يؤدي حذف مركبة لها حجز نشط إلى إرجاع خطأ `409 Conflict`، يتم التعامل معه بلطف مع رسالة مترجمة.
- يتيح `VehiclesListRefreshNotifier` (من نوع `ChangeNotifier`) التواصل بين الميزات، مما يسمح لأجزاء أخرى من التطبيق بتحديث قائمة المركبات.

**التواصل مع الخادم:**
- طلب `GET` لجلب جميع مركبات المستخدم المصادق عليه.
- طلب `POST` لإنشاء مركبة جديدة.
- طلب `PUT` لتحديث مركبة موجودة.
- طلب `DELETE` لحذف مركبة.

---

### 5.6 إدارة المواقف (المالك)

**ما تفعله:** يمكن لأصحاب المواقف تسجيل مواقف جديدة، وتحديث معلوماتها (الاسم، العنوان، السعر بالساعة، عدد الأماكن الإجمالي، إحداثيات الموقع)، وعرض لوحة تحكم تحتوي على إحصائيات الإشغال والإيرادات.

**كيف تعمل تقنيًا:**
- يدير `CreateParkingBloc` و`UpdateParkingBloc` حالة النماذج لإنشاء وتعديل المواقف على التوالي. يتم اختيار الإحداثيات باستخدام شاشة `MapLocationPickerScreen` المخصصة حيث يمكن للمالك سحب الخريطة لوضع دبوس تحديد الموقع.
- يدعم `ParkingListBloc` البحث والتصفية (حسب حالة الموقف) لأصحاب المواقف المتعددة.
- يجلب `ParkingStatsBloc` لوحة تحكم شاملة من الخادم تحتوي على إحصائيات ملخصة ونسب إشغال وبيانات مالية وتحليلات حجوزات. تعرض `ParkingDashboardScreen` هذه البيانات كبطاقات مؤشرات أداء رئيسية (KPI) ومؤشرات إشغال وأقسام إحصائيات.

**التواصل مع الخادم:**
- طلب `POST` لإنشاء موقف جديد.
- طلب `PUT` لتحديث موقف.
- طلب `GET` لجلب مواقف المالك.
- طلب `GET` لجلب إحصائيات لوحة التحكم المجمّعة.

---

### 5.7 المخالفات

**ما تفعله:** يمكن للسائقين عرض مخالفات مواقف السيارات الخاصة بهم، مقسمة إلى فئتي المدفوعة وغير المدفوعة، ودفع المخالفات المستحقة مباشرة عبر التطبيق.

**كيف تعمل تقنيًا:**
- يدير `ViolationsBloc` قائمتين منفصلتين (غير المدفوعة والمدفوعة). تستخدم واجهة المستخدم تخطيطًا قائمًا على علامات التبويب (Tabs).
- يؤدي دفع مخالفة إلى إرسال حدث `PayViolationRequested`. عند النجاح، يُعاد تحديث قائمة المخالفات غير المدفوعة تلقائيًا.
- تعرض كل مخالفة معلومات الموقف والمركبة المرتبطة بها، والتي يتم تحليلها من كائنات استجابة API المتداخلة.

**التواصل مع الخادم:**
- طلب `GET` لجلب المخالفات غير المدفوعة.
- طلب `GET` لجلب المخالفات المدفوعة (آخر 10 سجلات).
- طلب `POST` لدفع مخالفة محددة.

---

### 5.8 الإشعارات

**ما تفعله:** يتلقى المستخدمون إشعارات حول تأكيدات الحجوزات والمخالفات وأحداث النظام الأخرى. تُنظَّم الإشعارات في علامتي تبويب: غير مقروءة ومقروءة.

**كيف تعمل تقنيًا:**
- يقوم `NotificationsBloc` بتحميل جميع الإشعارات وفصلها إلى قائمتي غير مقروءة ومقروءة ضمن كيان `NotificationsResult`.
- يستخدم تعليم الإشعار كمقروء تقنية **التحديث المتفائل (Optimistic Updates)**: تنقل واجهة المستخدم الإشعار من قائمة غير المقروءة إلى قائمة المقروءة فورًا دون انتظار استجابة الـ API. إذا فشل استدعاء الـ API، يتم التراجع عن التغيير.
- طبقة العرض مُحسَّنة للأداء باستخدام `BlocSelector` (لتجنب إعادة البناء غير الضرورية) و`RepaintBoundary` (لعزل إعادة الرسم) وحسابات الأبعاد المخزنة مؤقتًا.
- تظهر شارة إشعارات على الشاشة الرئيسية تشير إلى عدد الإشعارات غير المقروءة.

**التواصل مع الخادم:**
- طلب `GET` لجلب جميع الإشعارات.
- طلب `PUT` لتعليم إشعار كمقروء.

---

### 5.9 إدارة الملف الشخصي

**ما تفعله:** يمكن للمستخدمين عرض وتعديل معلوماتهم الشخصية، وتغيير كلمة المرور، وتبديل لغة التطبيق، وحذف حسابهم.

**كيف تعمل تقنيًا:**
- ينفذ `ProfileBloc` **استراتيجية التخزين المؤقت أولًا (Cache-First)**: يعرض فورًا بيانات الملف الشخصي المخزنة مؤقتًا من `ProfileCacheService` (عبر SharedPreferences)، ثم يجلب أحدث البيانات من الـ API في الخلفية. هذا يوفر تجربة تحميل فورية.
- يدخل تعديل الملف الشخصي وضع التحرير ضمن نفس الشاشة. عند الحفظ، تُرسل البيانات المحدثة إلى الخادم ويُحدَّث التخزين المؤقت المحلي.
- يؤدي تحديث كلمة المرور وحذف الحساب إلى مسح جميع بيانات المصادقة المحلية وإعادة توجيه المستخدم إلى شاشة تسجيل الدخول.
- يتم تبديل اللغة عبر `LocaleCubit` الذي يحفظ التفضيل عبر `LanguageService` ويعيد بناء التطبيق باللغة الجديدة.

**التواصل مع الخادم:**
- طلب `GET` لجلب بيانات الملف الشخصي.
- طلب `PUT` لتحديث معلومات الملف الشخصي.
- طلب `PUT` لتغيير كلمة المرور.
- طلب `POST` لحذف الحساب.

---

## 6. معالجة الأخطاء وتجربة المستخدم

### 6.1 نموذج الأخطاء الموحد

يتم تحويل جميع أخطاء الـ API إلى فئة `AppException` موحدة تحمل:
- رمز حالة HTTP مثل `statusCode` (مثلًا: 401، 404، 422، 500).
- رمز خطأ خاص بالتطبيق `errorCode` كنص.
- رسالة مقروءة للمستخدم `message`.
- أخطاء حقول اختيارية `fieldErrors` لأخطاء التحقق على مستوى النموذج المُرجعة من الخادم.

هذه المركزية تعني أن جميع الميزات تتعامل مع الأخطاء من خلال واجهة واحدة ومتسقة.

### 6.2 رسائل الأخطاء المترجمة

تقوم أداة `LocalizedErrorMessages` بترجمة رموز أخطاء `AppException` إلى نصوص مترجمة باستخدام نظام الترجمة في التطبيق. يشمل ذلك الفئات التالية:

- **أخطاء الشبكة:** انتهاء مهلة الاتصال، عدم وجود اتصال بالإنترنت.
- **أخطاء المصادقة:** بيانات اعتماد غير صالحة، حساب غير نشط.
- **أخطاء التحقق:** بريد إلكتروني غير صالح، كلمة مرور قصيرة، رقم لوحة مكرر.
- **أخطاء الأعمال:** تعارض حجز، مركبة لها حجز نشط، موقف ممتلئ.
- **أخطاء الخادم:** خطأ عام في الخادم مع رسالة سهلة الفهم للمستخدم.

### 6.3 حالات التحميل والنجاح والخطأ

يتبع كل BLoC نمط حالات متسق:

- **حالة التحميل (Loading State):** تُصدر قبل استدعاء الـ API. تعرض واجهة المستخدم عنصر `LoadingWidget` (مؤشر تحميل دائري في المنتصف).
- **حالة النجاح (Success State):** تُصدر مع بيانات الاستجابة. تعرض واجهة المستخدم المحتوى.
- **حالة الخطأ (Error State):** تُصدر مع رسالة الخطأ. تعرض واجهة المستخدم عنصر `ErrorStateWidget` مع رسالة وصفية وزر "إعادة المحاولة".
- **حالة الفراغ (Empty State):** بعض الميزات (المركبات، الإشعارات، المخالفات) تصدر حالة فراغ مخصصة عندما يُرجع الـ API قائمة فارغة، مع عرض رسالة أو رسم توضيحي مفيد.

### 6.4 آليات التغذية الراجعة للمستخدم

- **UnifiedSnackbar:** نظام إشعارات فورية مخصص قائم على Overlay يدعم أربعة أنواع (نجاح، خطأ، معلومات، تحذير)، لكل منها ألوان وأيقونات مميزة. كونه قائمًا على Overlay يعني أن الرسائل تُعرض بشكل صحيح حتى فوق مربعات الحوار واللوحات السفلية.
- **تغذية راجعة للتحقق من النماذج:** تعرض حقول الإدخال نصًا مساعدًا افتراضيًا وتتحول إلى نص خطأ بحدود حمراء عند فشل التحقق. تُعرض أخطاء التحقق فقط بعد إرسال النموذج لتجنب الرسائل المبكرة.
- **التحديث المتفائل (Optimistic Updates):** تطبق ميزة الإشعارات تغييرات واجهة المستخدم فورًا (مثل نقل إشعار من غير مقروء إلى مقروء) وتتراجع إذا فشل استدعاء الـ API، مما يوفر تجربة مستخدم سريعة الاستجابة.
- **مربع حوار خطأ اتصال الـ API:** عند حدوث خطأ في اتصال الشبكة، يُعرض مربع حوار يتيح للمستخدم خيارات إعادة محاولة الطلب أو تغيير عنوان الخادم (مفيد أثناء التطوير) أو الإلغاء.

---

## 7. الأداء وجودة الكود البرمجي

### 7.1 العناصر المرئية القابلة لإعادة الاستخدام (Reusable Widgets)

يحتوي مجلد `core/widgets/` على مكتبة من العناصر المرئية المشتركة والقابلة للتكوين التي تُستخدم في جميع أنحاء التطبيق:

| العنصر المرئي | الغرض |
|---------------|-------|
| `CustomTextField` | حقل إدخال نصي موحد مع التحقق ونص مساعد وعرض الأخطاء وزر إظهار/إخفاء كلمة المرور. |
| `CustomElevatedButton` | زر مُنسَّق مع دعم حالة التحميل. |
| `CustomDropdownField` | قائمة منسدلة مُنسَّقة. |
| `CustomDatePickerField` | منتقي تاريخ مع عرض منسق. |
| `LoadingWidget` | مؤشر تحميل في المنتصف. |
| `ErrorStateWidget` | عرض خطأ مع إجراء إعادة المحاولة. |
| `InfiniteListViewWidget` | قائمة مع تحميل كسول ودعم التقسيم إلى صفحات (Pagination). |
| `UnifiedSnackbar` | إشعارات فورية قائمة على Overlay. |

من خلال مركزية هذه العناصر، يتجنب الكود التكرار ويضمن مظهرًا وسلوكًا موحدًا عبر جميع الشاشات.

### 7.2 فصل المسؤوليات

- **فئات BLoC** لا تحتوي على كود واجهة مستخدم؛ تعالج الأحداث فقط وتصدر الحالات.
- **فئات Use Case** لا تحتوي على منطق جلب البيانات؛ تفوّض إلى واجهات المستودعات.
- **تطبيقات المستودعات (Repository Implementations)** لا تحتوي على منطق أعمال؛ تحول استجابات الـ API إلى نماذج المجال (Domain Models).
- **عناصر العرض (Presentation Widgets)** لا تحتوي على استدعاءات API مباشرة؛ تتفاعل حصريًا من خلال أحداث BLoC.

هذا الفصل المنضبط يجعل كل مكون قابلًا للاختبار والاستبدال بشكل مستقل.

### 7.3 نظام تصميم متسق (Design System)

يعرّف مجلد `core/styles/` نظام تصميم مركزي:

- `AppColors`: جميع قيم الألوان المستخدمة في التطبيق، بما في ذلك اللوحة الأساسية وألوان الحالات والتدرجات اللونية وألوان مستويات الإشغال.
- `AppTextStyles`: أساليب نصية مبنية على السمة (Theme) مع طرق مصنعية (Factory Methods) لعناوين الحقول ونصوص الإدخال ونصوص الأزرار وعناوين البطاقات وغيرها.
- `AppDimens`: ثوابت التباعد والحشو ونصف قطر الحدود وأحجام الأيقونات وارتفاعات الأزرار.
- `AppDurations`: مدد الرسوم المتحركة وأوقات عرض الإشعارات الفورية ومهلات الشبكة وفترات الـ Debounce.

يضمن هذا النظام ثبات التصميم المرئي ويجعل تحديث التصميم على مستوى التطبيق بالكامل أمرًا سهلًا.

### 7.4 قابلية القراءة والصيانة

- **ملفات التصدير المجمّعة (Barrel Exports):** توفر كل وحدة ميزة ملف تصدير مجمّع (مثل `vehicles.dart` و`notifications.dart`) يعيد تصدير جميع الفئات العامة، مما يبسط عبارات الاستيراد (Import).
- **الثوابت المسماة والتعدادات (Enums):** يتم استبدال الأرقام والنصوص المبهمة بثوابت مسماة (`AppRoutes`، `AppDimens`، `AppDurations`) وتعدادات (`LoadingType`، `ValidationErrorType`).
- **Mixins لمعالجة الأخطاء:** تشترك الميزات في منطق معالجة الأخطاء من خلال Mixins (مثل `VehiclesErrorHandlerMixin` و`ViolationsErrorHandlerMixin`)، مما يقلل تكرار الكود في طبقة العرض.
- **مُبلِّغات التحديث (Refresh Notifiers):** يتم التواصل بين الميزات (مثل تحديث قائمة الحجوزات بعد الدفع) من خلال خدمات `ChangeNotifier` مسجلة في محدد الخدمات، مما يتجنب الترابط الوثيق بين الميزات.

### 7.5 التصميم المتجاوب (Responsive Design)

يستخدم التطبيق `flutter_screenutil` لتكييف جميع الأبعاد (أحجام الخطوط، الحشو، الهوامش، أحجام الأيقونات) مع حجم شاشة الجهاز. يغلف عنصر `ScreenUtilInit` التطبيق بالكامل ويحدد حجم تصميم مرجعي، مما يضمن أن واجهة المستخدم تبدو متناسبة على الشاشات الصغيرة والكبيرة على حد سواء.

---

## 8. اعتبارات الأمان

### 8.1 التعامل مع رموز المصادقة (API Token)

- تُخزَّن رموز المصادقة محليًا باستخدام **Hive**، وهي قاعدة بيانات خفيفة وسريعة تخزن البيانات بصيغة ثنائية (Binary) على نظام ملفات الجهاز.
- يتم بناء كل طلب API يتطلب مصادقة من خلال بانٍ `APIRequest` الذي يحقن رمز `Bearer` تلقائيًا في ترويسة `Authorization` عندما يكون خيار المصادقة `authorizationOption` مضبوطًا على `authorized`. هذا يلغي خطر نسيان المطورين تضمين الرمز يدويًا.
- عند تسجيل الخروج أو تغيير كلمة المرور أو حذف الحساب، تقوم دالة `clearAuthData()` في `AuthLocalRepository` بإزالة الرمز وبيانات المستخدم من التخزين المحلي.

### 8.2 تخزين البيانات الحساسة

- بيانات اعتماد المستخدم (البريد الإلكتروني وكلمة المرور) **لا تُخزَّن محليًا أبدًا**. يُحفظ فقط رمز المصادقة ومعلومات الملف الشخصي الأساسية (الاسم، البريد الإلكتروني، نوع المستخدم).
- بيانات الملف الشخصي المخزنة مؤقتًا للتحميل الفوري تُحفظ في SharedPreferences، وهو مناسب للبيانات غير الحساسة المعروضة. يتم تحديد حالة المصادقة الفعلية بواسطة الرمز المخزن في Hive.

### 8.3 أمان الشبكة

- يتم تكوين عميل Dio HTTP مع معترضات للطلبات والاستجابات. في وضع التطوير (Debug Mode)، تسجل هذه المعترضات تفاصيل الطلبات والاستجابات لأغراض التطوير؛ هذه السجلات غير نشطة في بناء الإصدار (Release Build).
- يدعم إعداد الـ API التبديل الديناميكي لعنوان الخادم، وهو مقتصر على بيئات التطوير والاختبار. يتيح هذا للفريق توجيه التطبيق إلى خوادم Backend مختلفة دون إعادة البناء.

### 8.4 التحقق من المدخلات (Input Validation)

- يتم التحقق من صحة جميع مدخلات المستخدم على جانب العميل قبل إرسالها إلى الخادم. يشمل ذلك التحقق من صيغة البريد الإلكتروني، وطول كلمة المرور (8 أحرف كحد أدنى)، وصيغة رقم الهاتف، والتحقق من الحقول المطلوبة.
- يتم أيضًا معالجة أخطاء التحقق من الخادم (HTTP 422) وعرضها للمستخدم برسائل مترجمة، مما يوفر طبقة مزدوجة من التحقق من المدخلات.

---

## 9. الخلاصة

### 9.1 نقاط القوة في المشروع

1. **تطبيق Clean Architecture:** الفصل الصارم إلى طبقات البيانات والمجال والعرض يضمن أن لكل مكون مسؤولية واحدة. هذا يجعل الكود قابلًا للصيانة والاختبار والتوسيع.

2. **مجموعة ميزات شاملة:** يغطي التطبيق دورة حياة المواقف بالكامل — من اكتشاف المواقف على الخريطة، مرورًا بالحجز والدفع، وصولًا إلى إدارة المخالفات وتحليلات جانب المالك. هذا يُظهر قدرة الفريق على بناء منتج واقعي متكامل.

3. **إدارة حالة احترافية:** الاستخدام المتسق لنمط BLoC مع أحداث وحالات محددة بوضوح وأداة AsyncRunner مخصصة يُظهر فهمًا ناضجًا للبرمجة التفاعلية وتدفق البيانات أحادي الاتجاه.

4. **دعم ثنائي اللغة:** الترجمة الكاملة بما يقارب 1,987 مفتاح ترجمة باللغتين العربية والإنجليزية تُظهر الاهتمام بإمكانية الوصول والجاهزية للسوق.

5. **التركيز على تجربة المستخدم:** ميزات مثل التحديث المتفائل للإشعارات، والتحميل من التخزين المؤقت أولًا للملف الشخصي، ومؤقتات العد التنازلي في الوقت الفعلي للحجوزات، والإشعارات الفورية القائمة على Overlay تعكس تركيزًا قويًا على توفير تجربة مستخدم سلسة وسريعة الاستجابة.

6. **معالجة أخطاء مركزية:** نموذج `AppException` الموحد ورسائل الأخطاء المترجمة وحالات التحميل/الخطأ/الفراغ المتسقة عبر جميع الميزات تُظهر نهجًا منهجيًا في إدارة الأخطاء.

7. **مكتبة مكونات قابلة لإعادة الاستخدام:** مكتبة العناصر المرئية المشتركة ونظام التصميم المركزي (الألوان، أنماط النصوص، الأبعاد، المدد) يعززان الثبات ويقللان الجهد التطويري.

8. **حقن تبعيات قابل للتوسع:** استخدام GetIt كمحدد خدمات مع تسجيل منظم بوضوح لمصادر البيانات والمستودعات وحالات الاستخدام وكائنات BLoC يمكّن التطبيق من التوسع بسلاسة مع إضافة ميزات جديدة.

### 9.2 ملاءمة المشروع كمشروع تخرج

هذا المشروع مناسب كمشروع تخرج للأسباب التالية:

- يعالج **مشكلة واقعية** (عدم كفاءة مواقف السيارات في المدن) بحل رقمي عملي.
- يُظهر إتقانًا **لمفاهيم Flutter المتقدمة** بما في ذلك Clean Architecture وإدارة الحالة بنمط BLoC وحقن التبعيات والتوجيه التصريحي والترجمة والتصميم المتجاوب.
- يتبع الكود **أفضل الممارسات في الصناعة** لهيكلة تطبيق Flutter متوسط إلى كبير الحجم، بما في ذلك فصل المسؤوليات والمكونات القابلة لإعادة الاستخدام والإعدادات المركزية.
- تُظهر الهيكلية متعددة الأدوار (سائق ومالك) القدرة على التعامل مع **مسارات مستخدمين مختلفة** ضمن تطبيق واحد.
- إن دمج **ميزات الخريطة** و**المؤقتات في الوقت الفعلي** و**التواصل بين الميزات** يضيف تعقيدًا تقنيًا ذا معنى يتجاوز عمليات CRUD الأساسية.

بشكل عام، يمثل تطبيق مواقف السيارات الذكي واجهة أمامية جوالة مُصممة هندسيًا بشكل جيد وغنية بالميزات، تعكس مبادئ هندسة برمجيات متينة وقدرة عملية على حل المشكلات.

---

*أُعدّ هذا التقرير لتوثيق تطبيق Flutter الأمامي (Frontend) لمشروع تخرج تطبيق مواقف السيارات الذكي. يُفترض أن الخادم الخلفي (Backend) ونقاط نهاية الـ API الخاصة به يعملان بشكل كامل ولم يتم تغطيتها في هذا التقرير.*
